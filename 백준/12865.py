N, K = map(int, input().split())
dp = [[0] * (K+1) for _ in range(N+1)]

for i in range(1, N+1):
    weight, value = map(int, input().split())

    for j in range(1, K+1):
        if j < weight:                  # 탐색하는 j가 무게보다 작으면 이전의 가치를 현재의 가치로 덮어씀 (1)
            dp[i][j] = dp[i-1][j]
        else:                           # 탐색하는 j가 무게이상인 경우 가치를 계산할 수 있음. (2)
            dp[i][j] = max(dp[i-1][j], dp[i-1][j - weight] + value)

print(dp[N][K])

"""
이 말 "탐색하는 j가 무게이상인 경우 가치를 계산할 수 있음" 의 경우

현재 무게(weight)이 3 인 경우 N+1(7)인 경우,
0, 1, 2 는 이전의 값을 복사하고 (1)
3 ~ 7 까지는 물건들의 가치합을 재정의한다는 의미 (2)

(2) 의 과정을 자세히 보면
현재 무게가 3이고 j가 3인 경우, 이전 무게 0과 현재 무게 3인 경우 해당 케이스 (j=3)
현재 무게가 3이고 j가 4인 경우, 이전 무게 1과 현재 무게 3인 경우 해당 케이스 (j=4)
현재 무게가 3이고 j가 5인 경우, 이전 무게 2과 현재 무게 3인 경우 해당 케이스 (j=5)
현재 무게가 3이고 j가 6인 경우, 이전 무게 3과 현재 무게 3인 경우 해당 케이스 (j=6)
현재 무게가 3이고 j가 7인 경우, 이전 무게 4과 현재 무게 3인 경우 해당 케이스 (j=7)
으로 해당 케이스들을 알 수 있음

하지만, 여기서 해당 케이스를 구하는 것이 아닌 최대 값을 구하는 것이므로, 
max(dp[i-1][j], dp[i-1][j - w[i]] + value) 로 가능한 최대 값을 구해야 함.
즉, dp[i-1][j] 이전의 경우의 값이 최고인지?
아님 현재의 케이스(이전에 올 수 있는 경우(dp[i-1][j-w[i]]) + 현재무게의 가치(value)) 가 가장 큰 값인지 구해야함.
위의 (2)의 과정을 설명한 경우임!
"""
